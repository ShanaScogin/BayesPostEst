---
title: "mcmcRocPrc() speed"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library("microbenchmark")
library("BayesPostEst")
```

Below is a 2nd version that works with less input (and no pre-processing to extract data). For speed improvements it has:

- uses a custom curve calculation
- uses `lapply` for the internal curve computations
- uses a custom AUC calculation

## Verify the ROC/PR curve calculations are identical to ROCR

### ROC

First, ROC. `f1()` uses ROCR to calculate the curve. `f2()` is a homebrew implementation. It has less checks but provided the inputs are non-missing, finite, numeric vectors, it should work correctly. It can handle duplicated predictions, e.g. an all constant prediction. 

```{r}
f1 <- function(pvec, yvec) {
  rocr_pred <- ROCR::prediction(predictions = pvec, labels = yvec)
  rocr_roc  <- ROCR::performance(prediction.obj = rocr_pred,
                                 measure = "tpr",
                                 x.measure = "fpr")
  roc_data <- data.frame(x = rocr_roc@x.values[[1]],
                         y = rocr_roc@y.values[[1]])
  roc_data
}

f2 <- function(pvec, yvec) {
  porder <- order(pvec, decreasing = TRUE)
  yvecs  <- yvec[porder]
  pvecs  <- pvec[porder]
  p      <- sum(yvecs)
  n      <- length(yvecs) - p
  tp     <- cumsum(yvecs)
  tpr    <- tp/p
  fp     <- 1:length(yvecs) - tp
  fpr    <- fp/n
  
  dup_pred  <- rev(duplicated(pvecs))
  dup_stats <- duplicated(tpr) & duplicated(fpr)
  dups <- dup_pred | dup_stats
  
  fpr <- c(0, fpr[!dups])
  tpr <- c(0, tpr[!dups])
  
  roc_data <- data.frame(x = fpr,
                         y = tpr)
  roc_data
}
```

Simple example to show duplicated values are correctly handled:

```{r}
set.seed(1234)
pvec <- sample(c(rep(.2, 5), rep(.5, 5), rep(.8, 5)), size = 15)
yvec <- rbinom(n = 15, size = 1, prob = pvec)

out1 <- f1(pvec, yvec)
out2 <- f2(pvec, yvec)
testthat::expect_identical(out1, out2)
out1
out2
```

This data is captured from inside `mcmcRocPrc2()` just prior to the curve calculations when `fullsims = TRUE`. Use one column (MCMC sample) for testing. 

```{r}
pred_prob <- readRDS("pred-prob.rds")
pvec <- pred_prob[, 1]
yvec <- jags_logit$model$data()$Y

microbenchmark::microbenchmark(
  f1(pvec, yvec),
  f2(pvec, yvec),
  times = 200
)
```

### Homebrew PR curve calculation.

```{r}
f1 <- function(pvec, yvec) {
  rocr_pred <- ROCR::prediction(predictions = pvec, labels = yvec)
  rocr_prc  <- ROCR::performance(prediction.obj = rocr_pred,
                                 measure = "prec",
                                 x.measure = "rec")
  prc_data <- data.frame(x = rocr_prc@x.values[[1]],
                         y = rocr_prc@y.values[[1]])
  prc_data
}

f2 <- function(pvec, yvec) {
  porder <- order(pvec, decreasing = TRUE)
  yvecs  <- yvec[porder]
  pvecs  <- pvec[porder]
  p      <- sum(yvecs)
  n      <- length(yvecs) - p
  tp     <- cumsum(yvecs)
  tpr    <- tp/p
  pp     <- 1:length(yvecs) 
  prec   <- tp/pp
  
  dup_pred  <- rev(duplicated(pvecs))
  dup_stats <- duplicated(tpr) & duplicated(prec)
  dups <- dup_pred | dup_stats
  
  prec <- c(NaN, prec[!dups])
  tpr <- c(0, tpr[!dups])
  
  prc_data <- data.frame(x = tpr,
                         y = prec)
  prc_data
}
```

Simple example to show duplicated values are correctly handled:

```{r}
set.seed(1234)
pvec <- sample(c(rep(.2, 5), rep(.5, 5), rep(.8, 5)), size = 15)
yvec <- rbinom(n = 15, size = 1, prob = pvec)

out1 <- f1(pvec, yvec)
out2 <- f2(pvec, yvec)
testthat::expect_identical(out1, out2)
out1
out2
```

Benchmark on full example.

```{r}
pred_prob <- readRDS("pred-prob.rds")
pvec <- pred_prob[, 1]
yvec <- jags_logit$model$data()$Y

microbenchmark::microbenchmark(
  f1(pvec, yvec),
  f2(pvec, yvec),
  times = 200
)
```

## Source code for v2

```{r}
source("../R/mcmcRocPrc.R")
mcmcRocPrc2
```

```{r}
data("sim_data")
data("jags_logit")
fit <- jags_logit
```


## curves = FALSE, fullsims = FALSE

```{r bm1}
f1 <- function() {
  mm <- model.matrix(Y ~ X1 + X2, data = sim_data)
  xframe <- as.matrix(model.frame(Y ~ X1 + X2, data = sim_data))
  mcmc <- coda::as.mcmc(fit)
  mcmc_mat <- as.matrix(mcmc)[, 1:ncol(xframe)]
  mcmcRocPrc(modelmatrix = mm,
             modelframe = xframe,
             mcmcout = mcmc_mat,
             curves = FALSE,
             fullsims = FALSE)
}
f2 <- function() {
  mcmcRocPrc2(jags_logit, "Y", c("X1", "X2"), curves = FALSE, fullsims = FALSE)
}

microbenchmark(
  f1(),
  f2(),
  times = 50L
)
```

## curves = TRUE, fullsims = FALSE

```{r bm2}
f1 <- function() {
  ## processing the data
  mm <- model.matrix(Y ~ X1 + X2, data = sim_data)
  xframe <- as.matrix(model.frame(Y ~ X1 + X2, data = sim_data))
  mcmc <- coda::as.mcmc(fit)
  mcmc_mat <- as.matrix(mcmc)[, 1:ncol(xframe)]
  
  mcmcRocPrc(modelmatrix = mm,
             modelframe = xframe,
             mcmcout = mcmc_mat,
             curves = TRUE,
             fullsims = FALSE)
}

f2 <- function() {
  mcmcRocPrc2(jags_logit, "Y", c("X1", "X2"), curves = TRUE, fullsims = FALSE)
}

microbenchmark(
  f1(),
  f2(),
  times = 50L
)
```



## curves = FALSE, fullsims = TRUE

```{r bm3}
f1 <- function() {
  ## processing the data
  mm <- model.matrix(Y ~ X1 + X2, data = sim_data)
  xframe <- as.matrix(model.frame(Y ~ X1 + X2, data = sim_data))
  mcmc <- coda::as.mcmc(fit)
  mcmc_mat <- as.matrix(mcmc)[, 1:ncol(xframe)]
  mcmcRocPrc(modelmatrix = mm,
                   modelframe = xframe,
                   mcmcout = mcmc_mat,
                   curves = FALSE,
                   fullsims = TRUE)
}

f2 <- function() {
  mcmcRocPrc2(jags_logit, "Y", c("X1", "X2"), curves = FALSE, fullsims = TRUE)
}

microbenchmark(
  f1(),
  f2(),
  times = 10L
)
```

## curves = TRUE, fullsims = TRUE

```{r bm4}
f1 <- function() {
  ## processing the data
  mm <- model.matrix(Y ~ X1 + X2, data = sim_data)
  xframe <- as.matrix(model.frame(Y ~ X1 + X2, data = sim_data))
  mcmc <- coda::as.mcmc(fit)
  mcmc_mat <- as.matrix(mcmc)[, 1:ncol(xframe)]
  mcmcRocPrc(modelmatrix = mm,
             modelframe = xframe,
             mcmcout = mcmc_mat,
             curves = TRUE,
             fullsims = TRUE)
}

f2 <- function() {
  mcmcRocPrc2(jags_logit, "Y", c("X1", "X2"), curves = TRUE, fullsims = TRUE)
}

microbenchmark(
  f1(),
  f2(),
  times = 10L
)
```




