#'This function calculates predicted probabilities for "average" cases after a Bayesian 
#'logit or probit model. It has the same functionality as \code{mcmcAveProb()}
#'function in this package; however, \code{mcmcSimAve()} automates the data preparation. 
#'For an explanation of predicted probabilities for "average" cases,
#'see e.g. King, Tomz & Wittenberg (2000) <doi: 10.2307/2669316>
#'@title Bayesian MCMC Predicted Probablities for the 'Average' Case
#'@description This function calculates predicted probabilities for "average" cases after 
#'a Bayesian logit or probit model. For an explanation of predicted probabilities for 
#'"average" cases, see e.g. King, Tomz & Wittenberg (2000) <doi: 10.2307/2669316>
#'@param formula A formula object, with the dependent variable on the
#'left of a ~ operator, and the independent variables on the right.
#'@param data A data frame, list or environment (or object coercible by
#'as.data.frame to a data frame) containing the variables in the model.
#'@param xinterest name of the explanatory variable for which to calculate 
#'associated Pr(y = 1).
#'@param sims MCMC object generated by R2jags, rjags, R2WinBUGS, R2OpenBUGS, 
#'MCMCpack, rstan, rstanarm. Currently only jags object is supported.
#'@param simout tbd
#'@param link type of model. It is a character vector set to 
#'"logit" (default) or "probit"
#'@param ci the bounds of the credible interval. Default is \code{c(0.05, 0.95)}.
#'@param fullsims logical indicator of whether full object (based on all MCMC draws 
#'rather than average) will be returned. Default is \code{FALSE}. A note: The longer 
#'range of x values is, the larger the full output will be if \code{TRUE} is selected.
#'@references King, G., Tomz, M., & Wittenberg, J. (2000). Making the most of 
#'statistical analyses: Improving interpretation and presentation. Available at 
#'SSRN 1083738. <doi: 10.2307/2669316>
#'@return This function returns a matrix with 4 columns:
#'\itemize{
#'\item predictor: identical to x_range
#'\item median_pp: median predicted probability at given x
#'\item lower_pp: lower bound of credible interval of predicted probability at given x
#'\item upper_pp: upper bound of credible interval of predicted probability at given x
#'}
#'@examples
#' \donttest{
#'   ## simulating data
#'   set.seed(123456)
#'   b0 <- 0.2 # true value for the intercept
#'   b1 <- 0.5 # true value for first beta
#'   b2 <- 0.7 # true value for second beta
#'   n <- 500 # sample size
#'   X1 <- runif(n, -1, 1)
#'   X2 <- runif(n, -1, 1)
#'   Z <- b0 + b1 * X1 + b2 * X2
#'   pr <- 1 / (1 + exp(-Z)) # inv logit function
#'   Y <- rbinom(n, 1, pr) 
#'   data <- data.frame(cbind(X1, X2, Y))
#'   
#'   ## formatting the data for jags
#'   datjags <- as.list(data)
#'   datjags$N <- length(datjags$Y)
#'   
#'   ## creating jags model
#'   model <- function()  {
#'   
#'   for(i in 1:N){
#'     Y[i] ~ dbern(p[i])  ## Bernoulli distribution of y_i
#'     logit(p[i]) <- mu[i]    ## Logit link function
#'     mu[i] <- b[1] + 
#'       b[2] * X1[i] + 
#'       b[3] * X2[i]
#'   }
#'   
#'   for(j in 1:3){
#'     b[j] ~ dnorm(0, 0.001) ## Use a coefficient vector for simplicity
#'   }
#'   
#'}
#' 
#' params <- c("b")
#' inits1 <- list("b" = rep(0, 3))
#' inits2 <- list("b" = rep(0, 3))
#' inits <- list(inits1, inits2)
#' 
#' ## fitting the model with R2jags
#' library(R2jags)
#' set.seed(123)
#' fit <- jags(data = datjags, inits = inits, 
#'          parameters.to.save = params, n.chains = 2, n.iter = 2000, 
#'          n.burnin = 1000, model.file = model)
#' 
#' ### average value approach
#' library(coda)
#' xmat <- model.matrix(Y ~ X1 + X2, data = data)
#' mcmc <- as.mcmc(fit)
#' mcmc_mat <- as.matrix(mcmc)[, 1:ncol(xmat)]
#' X1_sim <- seq(from = min(datjags$X1),
#'               to = max(datjags$X1), 
#'               length.out = 10)
#' ave_prob_sim <- mcmcSimAve(modelmatrix = xmat,
#'                         mcmcout = mcmc_mat,
#'                         xrange = X1_sim, 
#'                         xcol = 2)
#' }
#'@export
#'
mcmcSimAve <- function(formula,
                       data,
                       xinterest,
                       sims,
                       simout = 10, 
                       link = "logit", 
                       ci = c(0.025, 0.975),
                       fullsims = FALSE){
  
  # formula argument
  if(missing(formula)) {
    stop("Please enter the formula")
  }
  
  if(missing(data)) {
    stop("Please enter data")
  } else{
    modelmatrix <- model.matrix(object = formula, data = as.data.frame(data))
  }
  
  # range of x variable of interest argument
  if(missing(xinterest)) {
    stop("Please enter your variable of interest")
  } else {
    if(!(xinterest %in% variable.names(modelmatrix))) {
      stop("Variable name does not match any in the matrix. Please enter another.")
    } else {
      var <- data[ , grepl( xinterest , names( data ) ) ]
      xrange <- seq(from = min(var),
                    to = max(var),
                    length.out = simout)
    }
  }
  
  # fit variable
  if(missing(sims)) {
    stop("Please enter the mcmc fit output")
  } else {
    mcmcout <- as.matrix(coda::as.mcmc(sims))[, 1:ncol(modelmatrix)]
  }
  
  X <- matrix(rep(apply(X = modelmatrix,
                        MARGIN = 2,
                        FUN = function(x) median(x)),
                  times = length(xrange)),
              nrow = length(xrange),
              byrow = TRUE)
  colnames(X) <- variable.names(modelmatrix)
  if(!missing(xinterest)) {
    X[ , grepl( xinterest , variable.names( X ) ) ] <- xrange
  } else {
    X[, xcol] <- xrange
  }
  
  if(link == "logit"){
    logit_linpred <- t(X %*% t(mcmcout))
    logit_pp <- exp(logit_linpred) / (1 + exp(logit_linpred)) # still seems fine
    pp <- logit_pp}
  
  if(link == "probit"){
    pp <- pnorm(t(X %*% t(mcmcout)))
  }
  
  colnames(pp) <- as.character(xrange)
  longFrame <- reshape2::melt(pp)
  
  pp_dat <- dplyr::summarize(dplyr::group_by(longFrame, .data$Var2), 
                      median_pp = quantile(.data$value, probs = 0.5), 
                      lower_pp = quantile(.data$value, probs = ci[1]), 
                      upper_pp = quantile(.data$value, probs = ci[2]))
  
  names(pp_dat) <- c("predictor", "median_pp", "lower_pp", "upper_pp")
  
  if(fullsims == FALSE){
    return(pp_dat) # pp_dat was created by summarizing longFrame
  }
  
  if(fullsims == TRUE){
    names(longFrame) <- c("Iteration", "x", "pp")
    return(longFrame) 
  }
  
}