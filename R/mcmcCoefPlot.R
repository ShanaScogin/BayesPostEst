#' Coefficient Plots for MCMC Output
#'
#' Coefficient plots for MCMC output using `ggplot2`
#'
#' @param mod Bayesian model object generated by R2jags, rjags, R2WinBUGS, R2OpenBUGS, 
#' MCMCpack, rstan, rstanarm, and brms.
#' @param pars a scalar or vector of the parameters you wish to include in the table.
#' By default, \code{mcmcCoefPlot} includes all parameters saved in a model object. If a
#' model has lots of samples and lots of saved parameters, not explicitly specifying
#' a limited number of parameters to include via \code{pars} may take a long time
#' or produce an unreadable plot. \code{pars} can either be a vector with the
#' specific parameters to be included in the table e.g. \code{pars = c("beta[1]",
#' "beta[2]", "beta[3]")}, or they can be partial names that will be matched using
#' regular expressions e.g. \code{pars = "beta"}. Both of these will include
#' \code{beta[1]}, \code{beta[2]}, and \code{beta[3]} in the table.
#' @param pointest a character indicating whether to use the mean or median for
#' point estimates in the table.
#' @param ci a scalar indicating the confidence level of the uncertainty intervals.
#' @param hpdi a logical indicating whether to use highest posterior density intervals
#' or equal tailed credible intervals to capture uncertainty.
#' @param plot logical indicating whether to return a `ggplot` object or the
#' underlying tidy DataFrame.
#'
#' @return a `ggplot` object or a tidy DataFrame.
#' 
#' @author Rob Williams, \email{jayrobwilliams@gmail.com}
#'
#' @examples
#' data("jags_logit")
#' mcmcCoefPlot(jags_logit, pars = 'b')
#' 
#' @export
mcmcCoefPlot <- function(mod, pars = NULL, pointest = 'mean', ci = .95, hpdi = F, plot = T) {
  
  ## pull in unexported functions from other packages
  ## other options for future versions might include lifting this and adding authors as copr holders
  runjags.as.mcmc.list.runjags = getFromNamespace("as.mcmc.list.runjags", "runjags")
  if (inherits(mod, what = c("jags", "rjags"))) {
    samps <- as.matrix(coda::as.mcmc(mod))
  }
  if (inherits(mod, what = "bugs")) {
    samps <- mod$sims.matrix
  }
  if (inherits(mod, what = "runjags")) {
    samps <- as.matrix(runjags.as.mcmc.list.runjags(mod))
  }
  if (inherits(mod, what = c("mcmc", "mcmc.list", "stanfit", "stanreg",
                              "brmsfit"))) {
    samps <- as.matrix(mod)
  }
  
  if (!is.null(pars)) {
    samps <- samps[, grepl(pattern = paste(pars, collapse = '|'), x = colnames(samps))]
  }

  if (!hpdi) {
    samps_ci <- t(apply(samps, 2, quantile, probs = c(.5 - ci/2, .5 + ci/2)))
  } else if (hpdi) {
    samps_ci <- coda::HPDinterval(coda::as.mcmc(samps), prob = ci)
  } else {
    stop("hpdi must be either true or false")
  }
  
  if (pointest == 'mean') {
    samps_pe <- apply(samps, 2, mean)
  } else if (pointest == 'median') {
    samps_pe <- apply(samps, 2, median)
  } else {
    stop("pointest must be either 'mean' or 'median'")
  }
  
  coefs <- data.frame(pe = samps_pe, samps_ci)
  coefs$variable <- factor(rownames(coefs), levels = rev(rownames(coefs)))
  colnames(coefs)[2:3] <- c('lo', 'hi')
  
  ## return coefficient plot or underlying dataframe
  if (!plot) {
    coefs
  } else {
    ggplot2::ggplot(coefs, aes(x = variable, y = pe, ymin = lo, ymax = hi)) +
      ggplot2::geom_hline(yintercept = 0, lty = 2) +
      ggplot2::geom_pointrange() +
      ggplot2::coord_flip() + labs(x = '', y = '')
  }
  
}
