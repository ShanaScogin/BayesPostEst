#' R function for summarizing MCMC output in a regression-style table
#'@title Summarize Bayesian MCMC Output
#'@description R function for summarizing MCMC output in a regression-style table
#'@param sims MCMC object generated by R2jags, rjags, R2WinBUGS, R2OpenBUGS, MCMCpack, rstan, rstanarm
#'@param ci desired level for credible intervals; defaults to c(0.025, 0.975)
#'@param pars character vector of parameters to be printed; defaults to NULL (all parameters are printed)
#'@param Pr print percent of posterior draws with same sign as median; defaults to FALSE
#'@param ROPE vector of two values defining the region of practical equivalence; returns % of posterior to the left/right of ROPE
#'@return output
#'@examples
#' \donttest{
#'   set.seed(123456)
#'   example for user goes here
#'   unit testing goes in testthat
#' }
#'@export

mcmcTab <- function(sims, 
                    ci = c(0.025, 0.975), 
                    pars = NULL, 
                    Pr = FALSE,
                    ROPE = NULL) # add warning that for ROPE to be meaningful, all coefs/quantities must be on the same scale
{
  if(class(sims)[1] == "jags" || class(sims)[1] == "rjags"){
    sims <- as.matrix(as.mcmc(sims))
  }
  if(class(sims)[1] == "bugs"){
    sims <- sims$sims.matrix
  }  
  if(class(sims)[1] == "mcmc"){
    sims <- as.matrix(sims)
  }    
  if(class(sims)[1] == "mcmc.list"){
    sims <- as.matrix(sims)
  }      
  if(class(sims)[1] == "stanreg"){
    sims <- as.matrix(sims)
  } 
  if(class(sims)[1] == "stanfit"){
    sims <- as.matrix(sims)
  }     
  
  if(is.null(pars) == TRUE){
    dat <- sims
  }
  
  if(is.null(pars) == FALSE & length(pars) == 1){
    dat <- sims[, grepl(x = colnames(sims), pattern = pars)]
  }
  
  if(is.null(pars) == FALSE & length(pars) > 1){
    dat <- sims[, pars]
  }
  
  dat_wide <- t(dat)
  
  mcmctab <- apply(dat_wide, 1, 
                   function(x) c(Median = round(median(x), digits = 3), # Posterior median
                                 SD = round(sd(x), digits = 3), # Posterior SD
                                 Lower = as.numeric(round(quantile(x, probs = ci[1]), digits = 3)), # Lower CI of posterior
                                 Upper = as.numeric(round(quantile(x, probs = ci[2]), digits = 3)), # Upper CI of posterior
                                 Pr = round(ifelse(median(x) > 0, length(x[x > 0]) / length(x), length(x[x < 0]) / length(x)), digits = 3) # % of posterior draws with same sign as median
                   ))
  
  if(Pr == FALSE){
    mcmctab <- apply(dat_wide, 1, 
                     function(x) c(Median = round(median(x), digits = 3), # Posterior median
                                   SD = round(sd(x), digits = 3), # Posterior SD
                                   Lower = as.numeric(round(quantile(x, probs = ci[1]), digits = 3)), # Lower CI of posterior
                                   Upper = as.numeric(round(quantile(x, probs = ci[2]), digits = 3))))
  }

  if(is.null(ROPE) == FALSE){
    mcmctab <- apply(dat_wide, 1, 
                     function(x) c(Median = round(median(x), digits = 3), # Posterior median
                                   SD = round(sd(x), digits = 3), # Posterior SD
                                   Lower = as.numeric(round(quantile(x, probs = ci[1]), digits = 3)), # Lower CI of posterior
                                   Upper = as.numeric(round(quantile(x, probs = ci[2]), digits = 3)),
                                   PrOutROPE = round(ifelse(median(x) > 0, length(x[x > ROPE[2]]) / length(x), length(x[x < ROPE[1]]) / length(x)), digits = 3)))
  }
  
  # return(t(mcmctab))
  out_dat <- data.frame("Variable" = colnames(mcmctab), t(mcmctab),
                        row.names = NULL)
  return(out_dat)
}