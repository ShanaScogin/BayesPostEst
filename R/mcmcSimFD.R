## Combining mcmcLogitFD and mcmcProbitFD

#'@title First Differences of a Bayesian Logit or Probit model. This function 
#'has the same functionality as \code{mcmcFD()} in this package; 
#'however, \code{mcmcSimFD()} automates the data preparation.
#'@description R function to calculate first differences after a Bayesian logit or probit model 
#'@param formula A formula object, with the dependent variable on the
#'left of a ~ operator, and the independent variables on the right.
#'@param data A data frame, list or environment (or object coercible by
#'as.data.frame to a data frame) containing the variables in the model.
#'@param sims MCMC object generated by R2jags, rjags, R2WinBUGS, R2OpenBUGS, 
#'MCMCpack, rstan, rstanarm. Currently only jags object is supported
#'@param link type of model. It is a character vector set to 
#'"logit" (default) or "probit"
#'@param ci the bounds of the credible interval. Default is \code{c(0.025, 0.975)}.
#'@param percentiles default is \code{c(0.25, 0.75)}
#'@param fullsims logical indicator of whether full object (based on all MCMC draws 
#'rather than average) will be returned. Default is \code{FALSE}
#'@return output
#'@examples
#' \donttest{
#' ## simulating data
#' set.seed(123456)
#' b0 <- 0.2 # true value for the intercept
#' b1 <- 0.5 # true value for first beta
#' b2 <- 0.7 # true value for second beta
#' n <- 500 # sample size
#' X1 <- runif(n, -1, 1)
#' X2 <- runif(n, -1, 1)
#' Z <- b0 + b1 * X1 + b2 * X2
#' pr <- 1 / (1 + exp(-Z)) # inv logit function
#' Y <- rbinom(n, 1, pr) 
#' data <- data.frame(cbind(X1, X2, Y))
#' 
#' ## formatting the data for jags
#' datjags <- as.list(data)
#' datjags$N <- length(datjags$Y)
#' 
#' ## creating jags model
#' model <- function()  {
#'   
#'   for(i in 1:N){
#'     Y[i] ~ dbern(p[i])  ## Bernoulli distribution of y_i
#'     logit(p[i]) <- mu[i]    ## Logit link function
#'     mu[i] <- b[1] + 
#'       b[2] * X1[i] + 
#'       b[3] * X2[i]
#'   }
#'   
#'   for(j in 1:3){
#'     b[j] ~ dnorm(0, 0.001) ## Use a coefficient vector for simplicity
#'   }
#'   
#' }
#' 
#' params <- c("b")
#' inits1 <- list("b" = rep(0, 3))
#' inits2 <- list("b" = rep(0, 3))
#' inits <- list(inits1, inits2)
#' 
#' ## fitting the model with R2jags
#' set.seed(123)
#' fit <- R2jags::jags(data = datjags, inits = inits, 
#'                     parameters.to.save = params, n.chains = 2, n.iter = 2000, 
#'                     n.burnin = 1000, model.file = model)
#' 
#' ## running function
#' object_fd_sim <- mcmcSimFD(formula = Y ~ X1 + X2,
#'                  data = data,
#'                  sims = fit)
#' object_fd_sim
#' }
#'@export

mcmcSimFD <- function(formula,
                   data,
                   sims, 
                   link = "logit",
                   ci = c(0.025, 0.975),
                   percentiles = c(0.25, 0.75),
                   fullsims = FALSE) {
  
  # checking arguments
  if(missing(formula) | missing(data)) {
    stop("Please enter both the formula and data.")
  } else {
    modelmatrix <- model.matrix(object = formula, data = data)
    fdmat <- matrix(NA, ncol = 3, nrow = ncol(modelmatrix) - 1)
  }
  
  # sims argument
  if(missing(sims)) {
    stop("Please enter the mcmc fit output")
  } else {
    mcmcout <- as.matrix(coda::as.mcmc(sims))[, 1:ncol(modelmatrix)]
  }
  
  colnames(fdmat) <- c("Median", "Lower", "Upper")
  rownames(fdmat) <- colnames(modelmatrix)[-1]
  
  fdfull <- matrix(rep(NA),
                    ncol = ncol(modelmatrix) - 1,
                    nrow = nrow(mcmcout),
                    byrow = TRUE)
  colnames(fdfull) <- colnames(modelmatrix)[-1]
  
  for (i in 2:ncol(modelmatrix)){
    
    X <- matrix(rep(apply(X = modelmatrix,
                          MARGIN = 2,
                          FUN = function(x) median(x)),
                    times = 2),
                nrow = 2,
                byrow = TRUE)
    X[, i] <- ifelse(length(unique(modelmatrix[, i])) == 2 & 
                     range(modelmatrix[, i]) == c(0, 1), c(0, 1), 
                     quantile(modelmatrix[, i], probs = percentiles))
    
    # X[, i] <- quantile(modelmatrix[, i], probs = percentiles)
    
    Xb <- t(X %*% t(mcmcout))
    pp <- exp(Xb) / (1 + exp(Xb))
    
    fd <- pp[, 2] - pp[, 1]
    
    fdmat[i-1, 1] <- quantile(fd, probs = c(0.5))
    fdmat[i-1, 2] <- quantile(fd, probs = c(ci[1]))
    fdmat[i-1, 3] <- quantile(fd, probs = c(ci[2]))
    
    fdfull[, i-1] <- fd
    
  }
  
  fd.dat <- as.data.frame(fdmat)
  fd.dat$VarName <- rownames(fdmat)
  fd.dat$VarID <- row(fdmat)[, 1]
  
  if(fullsims == FALSE){
    return(fd.dat)
  }
  
  if(fullsims == TRUE){
    return(fdfull)
  }
  
}
