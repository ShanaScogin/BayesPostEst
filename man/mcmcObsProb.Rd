% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mcmcObsProb.R
\name{mcmcObsProb}
\alias{mcmcObsProb}
\title{Bayesian MCMC Observed Values Predicted Probablities}
\usage{
mcmcObsProb(modelmatrix, mcmcout, xinterest, xrange, xcol,
  link = "logit", ci = c(0.025, 0.975), fullsims = FALSE)
}
\arguments{
\item{modelmatrix}{model matrix, including intercept. Create with model.matrix(formula, data).
**Note: the order of columns in the model matrix must correspond to the order of columns 
in the matrix of posterior draws in the the \code{mcmcout} argument.**}

\item{mcmcout}{posterior distributions of all logit coefficients, 
in matrix form. This can be created from rstan, MCMCpack, R2jags, etc. and transformed
into a matrix using the function as.mcmc() from the coda package for \code{jags} class
objects, as.matrix() from base R for \code{mcmc}, \code{mcmc.list}, \code{stanreg}, and 
\code{stanfit} class objects, and \code{object$sims.matrix} for a \code{bugs} class object.
**Note: the order of columns in this matrix must correspond to the order of columns 
in the model matrix.**}

\item{xinterest}{semi-optional argument. Name of the explanatory variable for which 
to calculate associated Pr(y = 1). If \code{xcol} is supplied, this is not needed. 
If both are supplied, the function defaults to \code{xcol} and this argument is ignored}

\item{xrange}{name of the vector with the range of relevant values of the 
explanatory variable for which to calculate associated Pr(y = 1)}

\item{xcol}{posterior draws (\code{mcmcout}) column number of the explanatory 
variable for which to calculate associated Pr(y = 1)}

\item{link}{type of model. It is a character vector set to 
"logit" (default) or "probit"}

\item{ci}{the bounds of the credible interval. Default is \code{c(0.05, 0.95)}.}

\item{fullsims}{logical indicator of whether full object (based on all MCMC draws 
rather than average) will be returned. Default is \code{FALSE}. A note: The longer 
\code{xrange} is, the larger the full output will be if \code{TRUE} is selected.}
}
\value{
This function returns a matrix with 4 columns:
\itemize{
\item x: identical to x_range
\item median_pp: median predicted probability at given x
\item lower_pp: lower bound of credible interval of predicted probability at given x
\item upper_pp: upper bound of credible interval of predicted probability at given x
}
}
\description{
Implements R function to calculate the predicted probabilities
for "observed" cases after a Bayesian logit or probit model, following
Hanmer & Kalkan (2013) <doi: 10.1111/j.1540-5907.2012.00602.x>.
}
\details{
This function calculates predicted probabilities for 
"observed" cases after a Bayesian logit or probit model
following Hanmer & Kalkan (2013) <doi: 10.1111/j.1540-5907.2012.00602.x>.
}
\examples{
\donttest{
  ## simulating data
  set.seed(123456)
  b0 <- 0.2 # true value for the intercept
  b1 <- 0.5 # true value for first beta
  b2 <- 0.7 # true value for second beta
  n <- 500 # sample size
  X1 <- runif(n, -1, 1)
  X2 <- runif(n, -1, 1)
  Z <- b0 + b1 * X1 + b2 * X2
  pr <- 1 / (1 + exp(-Z)) # inv logit function
  Y <- rbinom(n, 1, pr) 
  data <- data.frame(cbind(X1, X2, Y))
  
  ## formatting the data for jags
  datjags <- as.list(data)
  datjags$N <- length(datjags$Y)
  
  ## creating jags model
  model <- function()  {
  
  for(i in 1:N){
    Y[i] ~ dbern(p[i])  ## Bernoulli distribution of y_i
    logit(p[i]) <- mu[i]    ## Logit link function
    mu[i] <- b[1] + 
      b[2] * X1[i] + 
      b[3] * X2[i]
  }
  
  for(j in 1:3){
    b[j] ~ dnorm(0, 0.001) ## Use a coefficient vector for simplicity
  }
  
}

params <- c("b")
inits1 <- list("b" = rep(0, 3))
inits2 <- list("b" = rep(0, 3))
inits <- list(inits1, inits2)

## fitting the model with R2jags
library(R2jags)
set.seed(123)
fit <- jags(data = datjags, inits = inits, 
          parameters.to.save = params, n.chains = 2, n.iter = 2000, 
          n.burnin = 1000, model.file = model)

### observed value approach
library(coda)
xmat <- model.matrix(Y ~ X1 + X2, data = data)
mcmc <- as.mcmc(fit)
mcmc_mat <- as.matrix(mcmc)[, 1:ncol(xmat)]
X1_sim <- seq(from = min(datjags$X1),
              to = max(datjags$X1), 
              length.out = 10)
obs_prob <- mcmcObsProb(modelmatrix = xmat,
                        mcmcout = mcmc_mat,
                        xrange = X1_sim,
                        xcol = 2)
}
}
\references{
Hanmer, M. J., & Ozan Kalkan, K. (2013). Behind the curve: Clarifying 
the best approach to calculating predicted probabilities and marginal effects from 
limited dependent variable models. American Journal of Political Science, 57(1), 
263-277.
}
